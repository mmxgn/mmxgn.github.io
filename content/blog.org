#+title: Manos' Blog
#+OPTIONS: toc:1

* About
Here I write about things I usually figure out, such as ~pytorch~ development in ~nix~, game development, or anything that piques my interest. If you want to discuss about something, reach me by [[mailto:etchourdakis@gmail.com][email]] or [[https://github.com/mmxgn/mmxgn.github.io/issues][github issues]].

* Refactoring and porting my Website repo to Nix with Claude   

I am an Emacs user (although with VI bindings) and keep my notes in org-mode using [[https://protesilaos.com/emacs/denote][Protesilaos' denote]]. I /love/ Org-mode. To my eyes it's the best note taking system available in software form.
At some point, I got across a great [[https://www.youtube.com/watch?v=AfkrzFodoNw&embeds_referring_euri=https%3A%2F%2Fsystemcrafters.net%2F&source_ve_path=MjM4NTE][video]] by [[https://systemcrafters.net/][SystemCrafters]] (also available as a post [[https://systemcrafters.net/publishing-websites-with-org-mode/building-the-site/][here]]) which showed how to create a website using Org-mode and ~org-html-publish-to-html~ (a function which creates ~html~ files from ~org~ files)
so I took some effort to port my then minimal html-only website to org-mode.

** The Problem

The way my website works, and worked before, was that had a custom ~build.sh~ shell script together with a ~build-site.el~ which was based on the [[https://www.youtube.com/watch?v=AfkrzFodoNw&embeds_referring_euri=https%3A%2F%2Fsystemcrafters.net%2F&source_ve_path=MjM4NTE][video]] by [[https://systemcrafters.net/][SystemCrafters]].
This would read the contents in ~content/~ and use ~org-html-publish-to-html~ to generate the html files under ~public~. Then, I commited ~public~ to my github pages repo. This worked fine
but it had some big issues:

+ The code used for building was not under version control.
+ I had to manually call ~build.sh~ and then ~git commit~ and ~git push~ every time I wanted to make an update.
+ If I wanted to preview the changes, I would do it with ~python -m http.serve~ which works fine but requires a system-wide installed python.
+ If I wanted to make a change from another computer, I would need to copy the whole folder, make the changes, and then repeat the steps in 2.

Of course this was a bit bothersome to maintain and it kills motivation to write to a degree. To alleviate the issues above, I had already planned some changes
which I never did:

+ Move the published website to a different repo than ~main~ and keep ~main~ for the building code.
+ Use GITHUB actions to render the website, instead of having to call ~build.sh~ every time.
+ Since I am using NixOS, create a reproducible environment which locked ~emacs~ and ~python~ for both rendering and previewing the website.

The reason for not fixing these was, I never found the motivation to work on those changes but since I recently got a personal Claude Code subscription to see what it's all about I asked /"why not?"/.

** Fixing Issues #1, and #2: Setting up a separate branch for publishing and continuous integration with github worfklows.

The first thing to do here, is to create a new branch ~gh-pages~ and set github pages to publish from there. See [[https://docs.github.com/en/pages/getting-started-with-github-pages/configuring-a-publishing-source-for-your-github-pages-site][here]]. Then, you must add ~public/~ to ~.gitignore~ to avoid commiting and pushing it manually (publishing will be done by github workflows from now on):

#+caption: ~.gitignore~
#+begin_src  :results raw :wrap example :exports both :session first
...
# Build artifacts
public/
...
#+end_src

Then, add the following to ~.github/worfklows/deploy.yaml~:

#+begin_src yaml :results raw :wrap example :exports both :session first
name: Build and Deploy Org Site

on:
  push:
    branches: [ main ]
  workflow_dispatch:  # Allow manual triggers

permissions:
  contents: write

jobs:
  build-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout source
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for proper git operations

      - name: Install Emacs
        run: |
          sudo apt-get update
          sudo apt-get install -y emacs-nox

      - name: Cache Emacs packages
        uses: actions/cache@v3
        with:
          path: .packages
          key: emacs-packages-${{ hashFiles('build-site.el') }}
          restore-keys: emacs-packages-

      - name: Build site
        run: |
          chmod +x build.sh
          ./build.sh

      - name: Deploy to gh-pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./public
          force_orphan: true  # Keep gh-pages clean
          user_name: 'github-actions[bot]'
          user_email: 'github-actions[bot]@users.noreply.github.com'
          commit_message: 'build: deploy site from ${{ github.sha }}'
#+end_src

Commit and push your changes to ~main~ now which properly tracks your code. Now every time you commit and push a change (e.g. in ~content/blog.org~) it will be
picked up by github actions and after a while you will have your website ready at your github-pages appointed url.

** Fixing Issues #3, and #4: Setting up a Nix Development Environment

The first thing I asked Claude Code  to do was (after initializing in the repo with ~init~) was to create the ~flake.nix~ file. Creating ~nix~ environments is my goto litmus test
for AI assistants since I've found they tend to fail on these a lot. It passed the test after a while, with some caveats, (I will make a post on the cases where  ~ClaudeCode~+~Sonnet~ combination still fails) creating
two targets ~build~ and ~serve~, which you can call with ~nix run .#<target>~ and do what you would expect. 

#+CAPTION:  ~flake.nix~ generated by Claude
#+begin_src nix
  {
    description = "Simple Org-mode Website";

    outputs = { self, nixpkgs, flake-utils }:
      flake-utils.lib.eachDefaultSystem (system:
        {

          # Emacs with htmlize which is needed for rendering org mode files
          emacs-with-packages = ...;
          
          # The website as a derivation
          buildSite = pkgs.stdenv.mkDerivation { ... };

          # The serving script
          serveScript = pkgs.writeShellScriptBin ...;

          # 
          devShells.default = ...;

          # Build the website to ./result
          packages.default = ...;

          # Convenient apps
          apps = {
            serve = ...;  # Build and serve locally
          };
        }
      );
  }
#+end_src

Now I could simply run:
#+begin_src bash
nix develop      # Enter dev environment
nix run .#serve  # Build and test locally
nix build        # Build for deployment
#+end_src

With this, I solved issues 3, and 4 above.  

** Minor enhancements with Claude Code

Having fixed the issues that related to building and deploying the website, I turned my attention to some other isses and enhancements I had in mind:

*** Setting up a nicer theme
I am quite fond of Deus Ex: Human Revolution. It is one of my favourite games of all times. So, when I saw that someone made a collection of [[https://github.com/tomaytotomato/jensen][themes]] based around its cyber-rennaisance colorscheme, I had to
add it everywhere, including my website. This was very easy, I just pointed Claude to Jensen's [[https://github.com/tomaytotomato/jensen/blob/main/README.md][README.md]] file, and it did the rest. While I was at it, I replaced the hovering menu on the right with a top bar, set some
nice transparencies and added a cyber-rennaisancy [[file:static/bg.png][background]] I quickly made in blender to better match the theme. 


*** Cache-Busting for Static Assets

One minor, but annoying issue I had was browser caching - visitors would see old CSS/JS even after updates. Claude implemented cache-busting by adding timestamps to asset URLs:

#+CAPTION: Cache-busting in ~build-site.el~
#+begin_src emacs-lisp
;; Generate timestamp-based version
(defvar cache-buster (format-time-string "%Y%m%d%H%M%S"))

(setq org-html-head
  (concat
    "<link rel=\"stylesheet\" href=\"static/style.css?v="
    cache-buster "\" />"))
#+end_src

Every build generates a new timestamp, forcing browsers to load fresh assets.

** The Workflow Now

My current workflow is beautifully simple:

#+caption: The current workflow 
#+begin_src bash
# 1. Edit content
emacs content/blog.org

# 2. Test locally
nix run .#serve

# 3. Commit and push
git add content/blog.org
git commit -m "feat: add new blog post"
git push

# GitHub Actions deploys automatically!
#+end_src

** Using This Setup Yourself

If you want to build your website the same way on github pages, just [[https://github.com/mmxgn/mmxgn.github.io][fork]] my repo on github, change the content, and follow the README.
* Developing with python and ~eglot~ using ~tramp~ :noexport:

** TODO Describe the issue

- [ ] Working remote with python
- [ ] Working with emacs/eglot+tramp
- [ ] No sudo access (even nix).
- [ ] Have docker 

** TODO Build a docker image with ~python-language-server~

#+caption: Dockerfile
#+begin_src docker :results raw :wrap example :exports both
FROM python:3.11-slim-bookworm
RUN pip install python-lsp-server[all]
CMD ["pylsp"]
#+end_src


** TODO Make sure it loads when calling ~eglot~

** TODO Next steps: Build a cuda compatible development environment


** References
- [ ]  https://nlited.de/using-helix-editor-with-a-dockerized-python-lsp

* Simulating VSCode's ~launch.json~ on Emacs with ~realgud~ and ~elgot~. :noexport:

** Disclaimer 
This has been tested on Emacs 30.2 installed on NixOS using the [[https://github.com/nix-community/emacs-overlay][Emacs Overlay]]. Your mileage might vary

** Instructions
Install [[https://github.com/realgud/realgud][realgud]] somehow. Its website has instructions on how to do it on non-nix systems. Below is how
I use it:

#+CAPTION: ~emacs.nix~
#+begin_src nix :results raw :wrap example :exports both
  {
    config,
    pkgs,
    inputs,
    ...
  }:
  {
    programs.emacs = {
      enable = true;
      package = (
        pkgs.emacsWithPackagesFromUsePackage {
          config = ./configs/init.el;
          defaultInitFile = true;
          package = pkgs.emacs30-pgtk;
          extraEmacsPackages = epkgs: with epkgs; [ realgud ];
        }
      );
    };
  }
#+end_src

and enable it simply by:

#+CAPTION: ~init.el~
#+begin_src emacs-lisp :results raw :wrap example :exports both
(require 'realgud) 
#+end_src

** Add 





   

* NixOS: Using a beefy desktop to build packages for raspberry pi :noexport:
** The Problem
In my home network, I have a Raspberry Pi 400 as my media server / emuation station which
runs (of course) NixOS. Unfortunately, an issue I have is that when I run ~nh os boot --update~,
it takes forever, especially if I am updating a package which needs compilation. Below I give simple instructions on
how to overcome this issue by showing how to set up the Desktop PC (running NixOS) to build packages for my Raspberry Pi.

** Specification 

Both the *Desktop PC* *Raspberry Pi 400* running NixOS 25.05 (unstable). They're connected through Wi-Fi, and can see each other
through a tailscale network via hostnames ~desktop~, and ~rpi400~.

** Setting up cross-compilation for the desktop

The first step, is to set up ~desktop~ for cross-compilation of arm packages. This can be done by adding the following to the
NixOS configuration (I am using modules but copy/pasting the body of the modules directly in ~configuration.nix~ will work).

#+begin_src nix

#+end_src

** Setting up a remote builder

On ~rpi400~, create an SSH key pair:

#+begin_src bash
[root@pi:~]# ssh-keygen -f /root/.ssh/remotebuild
Generating public/private ed25519 key pair.
Enter passphrase for "/root/.ssh/remotebuild" (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in /root/.ssh/remotebuild
Your public key has been saved in /root/.ssh/remotebuild.pub
The key fingerprint is:
SHA256:sOm4t3V0yMirUKft6HJhA/WHkPW1ND5vr+4xdc2Uvso root@pi
The key's randomart image is:
+--[ED25519 256]--+
|       o.   +    |
|      +  . + o  .|
|     ..o .. +  ..|
|    .  =oo.. o.o.|
|     .+ S.+ . o.=|
|     +++ o . . oo|
|    o.oo+ .   o..|
|    .oo= .  . .+ |
|    .==..    E+  |
+----[SHA256]-----+
#+end_src

Copy ~remo

Create the following module (or add the options directly to ~configuration.nix~):
#+CAPTION: ~remote-build.nix~
#+begin_src nix 
{ nix, users, ... }:
{
  users.users.remotebuild = {
    isNormalUser = true;
    createHome = false;
    group = "remotebuild";
    openssh.authorizedKeys.keyFiles = [ ./remotebuild.pub ];
  };

  users.groups.remotebuild = { };
  nix.settings.trusted-users = [ "remotebuild" ];
}
#+end_src

Make sure that ~remote-build.nix~ and ~remotebuild.pub~ is on the same directory as the module, and that it is tracked by git (adapt accordingly
for ~configuration.nix~).

You should now check that you can access ~desktop~ from ~rpi400~ using the ~remotebuild~ private key:

#+begin_src bash
 # From rpi400
 ssh remotebuild@desktop -i /root/.ssh/remotebuild "echo hello"
 hello
 Could not chdir to home directory /home/remotebuild: No such file or directory
#+end_src

Ignore the last error message, it just confirms that user ~remotebuild~ bas no home directory, as directed by ~createHome = false;~ above.

Finally, set the following to ~rpi400~'s config:

#+begin_src nix
  # Force the system to build remotely
  nix.settings.cores = 0;
  nix.settings.max-jobs = 0;
#+end_src

** References
- https://nix.dev/tutorials/nixos/distributed-builds-setup.html
- https://blog.thalheim.io/2022/11/27/cross-compiling-and-deploying-nixos/


* Run Godot made games/apps on NixOS 
Trying to run games (or apps) made in Godot in Nixos will result in (in this example [[https://deakcor.itch.io/pixelover][Pixelover]]):
#+begin_src bash
mmxgn@emerdesktop ~/Downloads/pixelover-linux-demo $ ./PixelOver.x86_64  
Could not start dynamically linked executable: ./PixelOver.x86_64
NixOS cannot run dynamically linked executables intended for generic
linux environments out of the box. For more information, see:
https://nix.dev/permalink/stub-ld
#+end_src

The correct nix approach would be to create a derivation with all the necessary dependencies and patchelf the binaries. However
noone has time for that. [[https://discourse.nixos.org/t/tips-tricks-for-nixos-desktop/28488/2][Here]]'s a solution that has served me well:

#+begin_src nix
  environment.systemPackages = with pkgs; [
    (let base = pkgs.appimageTools.defaultFhsEnvArgs; in
      pkgs.buildFHSEnv(base // {
      name = "fhs";
      targetPkgs = pkgs: 
        (base.targetPkgs pkgs) ++ (with pkgs; [
          pkg-config
          ncurses
          zsh
          mesa
          libglvnd
          wayland
          wayland-protocols
          glfw
        ]
        );
      LD_LIBRARY_PATH = with pkgs; lib.makeLibraryPath [
        mesa
        libglvn
      ];
      profile = "export FHS=1";
      runScript = "zsh";
      extraOutputsToInstall = ["dev"];
    }))
  ];
#+end_src

Then by running ~fhs~ first, you can simply execute the binary as you would under an FHS-compliant distribution:
#+begin_src bash
    mmxgn@emerdesktop ~/Downloads/pixelover-linux-demo $ fhs
    mmxgn@emerdesktop ~/Downloads/pixelover-linux-demo $ ./PixelOver.x86_64
#+end_src

#+CAPTION: Pixelover is a great app for converting your 3d models to 2d sprites (spaceship model by yours truly).
[[./static/pixelover.png]]
* *WIP* Building a new website with Org-mode :noexport:
** Prelude
My previous website was made in html. I had made the deliberate choice not to use a framework such as /Hugo/ or /Pelican/ since they seemed overly complicated for what I wanted to do: /Have a central point of information about me, for people wanting to hire me/. I believe I have grown out of it however since I need something akin to a blog. I constantly come across interesting stuff and problems that I solve and I would like to share them with others.


** Why Org-mode of all?
I have been using ~org-mode~ all along as a note-taking and app for writing documentation. I have written most of my notes in ~org~ already so sharing something should come with minimal overhead and thus I will be more motivated to share. Furthermore, I love ~org~'s simplicity, ability to beautifully interpolate code blocks, /images/, /math/, even /graphs/ within text. See e.g. Listing [[listing1]] and Formula [[dft]]

#+caption: Example python code highlighting
#+name: listing1
#+begin_src python :results raw :wrap src :exports both
import numpy as np
def dft(xn: np.ndarray) -> np.ndarray:
    """
    Computes the discrete fourier transform
    """
    N = K = xn.shape[-1]
    xk = np.zeros(K, dtype='complex')
    for k in range(K):
        xk[k] = np.sum(xn * np.exp(-2*1j*np.pi*k/N * np.arange(N)))
    return xk
return dft(np.array([1,2,3,4]))
#+end_src

#+CAPTION: Results
#+RESULTS: listing1
#+begin_src
[10.+0.00000000e+00j -2.+2.00000000e+00j -2.-9.79717439e-16j
 -2.-2.00000000e+00j]
#+end_src



#+CAPTION: The Discrete Fourier Transform
#+NAME: dft
#+BEGIN_CENTER
\begin{equation}
\label{dft}
X_{k} = \sum_{n=0}^{N-1}x_{n}\exp\{-2j\pi \frac{k}{N}n\}
\end{equation}
#+END_CENTER
** Automating Deployment

My plan is to take publishing a little bit further than just a website and a blog. Since I am writing stuff in ~org-mode~ and I am using ~emacs~, there is no reason why I wouldn't be able to maintain in ~org~, e.g. my CV as well.

#+begin_src dot :results raw :wrap attr_html :exports results :eval no-export :file static/plan.png
digraph plan {
             rankdir = "LR";
        A[label="Write .org files" shape="box"];
        B[label="Git commit/push" shape="box"];
        C[label="Produce .html files" shape="box"];
        D[label="Produce .pdf files" shape="box"];
        E[label="Publish"];

        A -> B -> {C, D} -> E;

}
#+end_src

#+RESULTS:
#+begin_attr_html
[[file:static/plan.png]]
#+end_attr_html

My goal is to simplify deployment by using Github actions. I do not want to run a script in order to generate ~html~ code, rather i would like github actions to do that for me.
* How I work with CUDA and ~devenv~ for developing with ~python/pytorch~ in NixOS

** Disclaimer
What I write applies to the following:

 - *Date*: Jan 30, 2025
 - *NixOS version* =25.05= (unstable)
 - *Nixpkgs* channel ~github:nixos/nixpkgs/nixos-unstable~
 - *Nvidia Drivers / CUDA Version*: =565.77= / =12.7=

Your mileage may vary, especially if visiting this article in the future.

** The problem

Machine learning with python was one of my big pain with NixOS that occasionally brought me close to abandoning it. There is no single way to make things work and if not using python from ~nixpkgs~ it is almost guaranteed to break (e.g. during compilation of ~numpy~ or something similar). Furthermore, trying different ways requires writing lots of boilerplate code which can be hard to convince your colleagues to add to the git repo. I have figured two ways to keep my sanity: by *using docker* and by *using devenv*. Here I write about the latter while I might write about the former in the future:

** ~devenv~ to the rescue
I recently came across [[https://devenv.sh/][devenv]] which looks promising as an easy way to let me collaborate with colleagues on ml-based python projects while still using NixOS on my local environment and not having to fight through docker shenanigans (fixing for permissions, working with git repositories, and stuff). It is easy, first include it with:

#+CAPTION: ~configuration.nix~
#+begin_src nix :results raw :wrap example :exports both :eval no-export
environment.systemPackages = [
  pkgs.devenv
];
#+end_src

Then, after rebuilding from ~configuration.nix~, switch to your repository on your disk and run:
#+begin_src nix :results raw :wrap example :exports both :eval no-export
# Initialise a devenv package
devenv init
#+end_src

And use the following ~devenv.nix~, and ~devenv.yaml~ file (remember to change the python version and ~requirements.txt~ file):

#+CAPTION: ~devenv.nix~
#+begin_src nix :results raw :wrap example :exports both :eval no-export
{ pkgs, lib, config, inputs, ... }:
{

  # Required for compiling numpy
  packages = [ pkgs.libz ];

  languages.python = {
    enable = true;
    version = "3.10";
    venv.enable = true;
    venv.requirements = ./requirements.txt;
  };

  # This is required if you want your module to see cuda
  env.LD_LIBRARY_PATH = "/run/opengl-driver/lib";
}
  #+end_src

 #+CAPTION: devenv.yaml
 #+begin_src yaml :results raw :wrap example :exports both :eval no-export
inputs:
  nixpkgs-python:
    url: github:cachix/nixpkgs-python
    inputs:
      nixpkgs:
        follows: nixpkgs
  nixpkgs:
    url: github:cachix/devenv-nixpkgs/rolling

 #+end_src

 #+CAPTION: An example ~requirements.txt~ file
 #+begin_src pip :results raw :wrap example :exports both :eval no-export
numpy
torch
torchaudio
torchvision
 #+end_src

So, finally, after ~devenv shell~:

#+begin_src bash :results raw :wrap example :exports both :eval no-export
python -c 'import torch; print(torch.cuda.is_available())'
#+end_src

#+RESULTS:
#+begin_example
True
#+end_example

Devenv will also modify your ~.gitignore~ file to include itself, don't forget to stage it with ~git stage .gitignore~.
#+begin_src diff :results raw :wrap example :exports both :eval no-export
diff --git a/.gitignore b/.gitignore
index 51aa465..7fd8971 100644
--- a/.gitignore
+++ b/.gitignore
@@ -33,3 +33,12 @@ build/*
 **/checkpoint*
 **/output**.wav
 **/*.ipynb
+# Devenv
+.devenv*
+devenv.local.nix
+
+# direnv
+.direnv
+
+# pre-commit
+.pre-commit-config.yaml
#+end_src

** Troubleshoot
*** Importing ~module~ fails with ~ImportError: libXXX.so.X: cannot open shared object file: No such file or directory~
If you get an error like:

#+begin_src log :results raw :wrap example :exports both :eval no-export
>>> import numpy
Traceback (most recent call last):
  File "<your-path>/.devenv/state/venv/lib/python3.10/site-packages/numpy/_core/__init__.py", line 23, in <module>
    from . import multiarray
  File "<your-path>/.devenv/state/venv/lib/python3.10/site-packages/numpy/_core/multiarray.py", line 10, in <module>
    from . import overrides
  File "<your-path>/.devenv/state/venv/lib/python3.10/site-packages/numpy/_core/overrides.py", line 7, in <module>
    from numpy._core._multiarray_umath import (
ImportError: libz.so.1: cannot open shared object file: No such file or directory

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "<your-path>/.devenv/state/venv/lib/python3.10/site-packages/numpy/__init__.py", line 114, in <module>
    from numpy.__config__ import show_config
  File "<your-path>/.devenv/state/venv/lib/python3.10/site-packages/numpy/__config__.py", line 4, in <module>
    from numpy._core._multiarray_umath import (
  File "<your-path>/.devenv/state/venv/lib/python3.10/site-packages/numpy/_core/__init__.py", line 49, in <module>
    raise ImportError(msg)
ImportError:

IMPORTANT: PLEASE READ THIS FOR ADVICE ON HOW TO SOLVE THIS ISSUE!

Importing the numpy C-extensions failed. This error can happen for
many reasons, often due to issues with your setup or how NumPy was
installed.

We have compiled some common reasons and troubleshooting tips at:

    https://numpy.org/devdocs/user/troubleshooting-importerror.html

Please note and check the following:

  * The Python version is: Python3.10 from "<your-path>/.devenv/state/venv/bin/python"
  * The NumPy version is: "2.2.2"

and make sure that they are the versions you expect.
Please carefully study the documentation linked above for further help.

Original error was: libz.so.1: cannot open shared object file: No such file or directory


The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<your-path>/.devenv/state/venv/lib/python3.10/site-packages/numpy/__init__.py", line 119, in <module>
    raise ImportError(msg) from e
ImportError: Error importing numpy: you should not try to import numpy from
        its source directory; please exit the numpy source tree, and relaunch
        your python interpreter from there.
>>>
#+end_src

The solution is to add the corresponding ~pkgs.<library>~ in ~devenv.nix~. If you don't know what that is, you can figure it out with [[https://github.com/nix-community/nix-index][nix-locate]]:

E.g.:

#+begin_src bash :results raw :wrap example :exports both :eval no-export
# First create the index
nix-index

# Then find the corresponding package
nix-locate 'libz.so.1'
#+end_src

#+RESULTS:
#+begin_example
...
zlib.out                                              0 s /nix/store/jb442jir0a2x7zsk0d63xb6rh8p280ai-zlib-1.3.1/lib/libz.so.1
zlib.out                                        128,584 x /nix/store/jb442jir0a2x7zsk0d63xb6rh8p280ai-zlib-1.3.1/lib/libz.so.1.3.1
...
libz.out                                              0 s /nix/store/x4hgdkl1i7x76phgkqv24m70jawqa7jm-libz-1.2.8.2015.12.26-unstable-2018-03-31/lib/libz.so.1
libz.out                                        107,680 r /nix/store/x4hgdkl1i7x76phgkqv24m70jawqa7jm-libz-1.2.8.2015.12.26-unstable-2018-03-31/lib/libz.so.1.2.8
...
#+end_example

And now you can add ~pkgs.libz~ to ~devenv.nix~:

#+begin_src  :results raw :wrap example :exports both :eval no-export
...
packages = [ pkgs.libz ];
...
#+end_src

Another usual suspect is ~cv2~ which requires ~pkgs.libGL~ and ~pkgs.glib~.
* Robustifying training of generative models in pytorch :noexport:
** The problem
- Lack of sanitization of inputs for lower precisions (i.e. float16)
- Lack of messaging when things go wrong


Training a generative model (e.g. a VAE) means training with very unstable loss functions. For example, let's take the loss function for a classical VAE that enforces a standard normal over the latents:




\begin{equation}
\mathcal{L}(x, x') = \underbrace{||x-x'||_{2}^{2}}_{\text{reconstruction part}} - \beta \underbrace{D_\text{KL}\left( q(z|x)\right)}_{\text{regularization}}
\end{equation}

where $D_{\text{KL}}$ is the Kullback-Leibler divergence of  $q(z|x)$ from the standard multivariate normal $\mathcal{N}{(\mu, \mathbf\sigma \odot \mathbf{I})}$. This is given simply by:
\begin{equation}
D_{\text{KL}}(q) = \frac{1}{2}\left [ \sigma_{q}^{2} + \mu_{q}^{2} -1 - \log(\sigma_{q}^{2}) \right ]
\end{equation}

Practically, $\sigma_q$ and $\mu_q$ are approximated from the "batch" of latents $z$, as $\mu_{q} = \frac{1}{B}\sum_i^B{z_i}$ and $\sigma_q = \frac{1}{B}\sum_{i}^B\left|z_{i}  - \mu_{q} \right|^2$.


* Welcome

Your content here!
EOF

# Create your blog
cat > content/blog.org <<EOF
#+title: My Blog
#+OPTIONS: toc:t

* About
Write about yourself here.

* My First Post
Your first blog post!
EOF
#+end_src

*** Customize the Site

Edit =build-site.el= to change:
- Site title and metadata
- CSS stylesheets
- Author information
- Publishing options

#+CAPTION: Example customization in ~build-site.el~
#+begin_src emacs-lisp
(setq org-publish-project-alist
  (list
    (list "org-site:main"
      :author "Your Name"  ; Change this
      :with-email nil
      ...)))
#+end_src

*** Build and Test

#+CAPTION: Local development workflow
#+begin_src bash
# Build and serve on http://localhost:8000
nix run .#serve

# Or build manually
./build.sh
cd public
python -m http.server 8000
#+end_src

*** Deploy to GitHub Pages

1. Create a new repository on GitHub (e.g., =username.github.io=)
2. Set up the git worktree structure:

#+CAPTION: Initialize git branches
#+begin_src bash
git checkout -b main
git add .
git commit -m "feat: initial website"

# Create deployment branch
git checkout --orphan gh-pages
git reset --hard
git commit --allow-empty -m "feat: initialize deployment"
git checkout main

# Set up worktree
git worktree add public gh-pages
#+end_src

3. Push to GitHub:

#+CAPTION: Push to GitHub
#+begin_src bash
git remote add origin git@github.com:username/username.github.io.git
git push -u origin main
git push -u origin gh-pages
#+end_src

4. Enable GitHub Pages in your repository settings:
   - Go to Settings â†’ Pages
   - Set Source to =gh-pages= branch
   - Save

5. Every push to =main= will now auto-deploy! ðŸŽ‰

*** Customizing the Theme

The site uses the Jensen theme with customizable colors. Edit =content/static/style.css= to change:

#+CAPTION: Color variables in ~style.css~
#+begin_src css
:root {
  --jensen-bg: #141514;      /* Background */
  --jensen-fg: #FBFBFB;      /* Text */
  --jensen-gold: #EDA622;    /* Accent color */
  /* ... more colors ... */
}
#+end_src

** Conclusion

What would have taken me days of reading documentation and trial-and-error took a few hours of interactive conversation with Claude. The result is a maintainable, reproducible development environment with automated deployment.

If you're struggling with similar infrastructure challenges, I highly recommend trying Claude Code. It's like having an experienced DevOps engineer available 24/7.

The best part? You can clone this setup and have your own org-mode website running in minutes!

** Resources

- My website: [[https://mmxgn.github.io][mmxgn.github.io]]
- Source code: [[https://github.com/mmxgn/mmxgn.github.io][GitHub repository]]
- [[https://nixos.org/manual/nix/stable/][Nix Manual]]
- [[https://orgmode.org/][Org-mode]]
- [[https://github.com/tomaytotomato/jensen][Jensen Theme]]
- [[https://claude.ai/][Claude AI]]
